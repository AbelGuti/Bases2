{
  "name": "listener-collection",
  "version": "0.1.0",
  "description": "node.js library adding async support to events",
  "main": "index.js",
  "scripts": {
    "test": "mocha test"
  },
  "keywords": [
    "event",
    "async"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/pofider/node-listener-collection.git"
  },
  "author": {
    "name": "Jan Blaha"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/pofider/node-listener-collection/issues"
  },
  "homepage": "https://github.com/pofider/node-listener-collection#readme",
  "devDependencies": {
    "mocha": "^2.3.3",
    "should": "^5.2.0"
  },
  "dependencies": {
    "async": "0.9.0",
    "q": "1.2.0",
    "underscore": "1.8.3"
  },
  "readme": "# node-listener-collection\r\n\r\n[![Build Status](https://travis-ci.org/pofider/node-listener-collection.png?branch=master)](https://travis-ci.org/pofider/node-listener-collection)\r\n\r\nThis library extends the standard event mechanism with ability to wait until all asynchronous events are processed.\r\n\r\n> npm install listener-collection\r\n\r\n\r\n##Callback based\r\n```js\r\nvar ListenerCollection = require(\"listener-collection\");\r\n\r\nvar liseners = new ListenerCollection();\r\n\r\nlisteners.add(\"listener1\", function(param1, param2, next) {\r\n   setTimeout(function() {\r\n     console.log(\"listener\");  \r\n     next();\r\n   }, 100);\r\n});\r\n\r\nlisteners.add(\"listener2\", function(param1, param2, next) {\r\n   setTimeout(function() {\r\n     console.log(\"listener2\");  \r\n     next();\r\n   }, 200);\r\n});\r\n\r\nlisteners.fire(\"A\", \"B\", function() {\r\n  console.log(\"both listeners are processed now\");\r\n});\r\n```\r\n\r\n##Promise based\r\n```js\r\nvar ListenerCollection = require(\"listener-collection\");\r\n\r\nvar liseners = new ListenerCollection();\r\n\r\nlisteners.add(\"a name\", function(param1, param2) {\r\n   console.log(\"listener catch\");  \r\n   return promise;   \r\n});\r\n\r\nlisteners.fire(\"A\", \"B\").then(function() {\r\n  console.log(\"everything is done\");\r\n});\r\n```\r\n\r\n##Listener context\r\n\r\n```js\r\nlisteners.add(\"a name\", context, function() {\r\n   //this runs bound to context\r\n});\r\n```\r\n\r\n##Listener position\r\n\r\nListeners are executed one by one in order they were added.  If you want to add a listener to a particular position you can use `insert` and specify the condition when the listener should be invoked.\r\n\r\n```js\r\nlisteners.add(\"listener1\", function() { ... });\r\nlisteners.add(\"listener2\", function() { ... });\r\nlisteners.insert({ after: \"listener1\" }, \"listener3\", function() { ... });\r\n```\r\nAlternatively you can also use `before` instead or together with `after`. \r\n\r\n##Removing listener\r\n\r\n```js\r\nlisteners.add(\"test\", function () { });\r\nlisteners.remove(\"test\");\r\n```\r\n\r\n\r\n##Hooks\r\n\r\n\r\n```js\r\nlisteners.post(function() {\r\n  console.log(\"this runs after the listeners are invoked\");\r\n});\r\n\r\nlisteners.pre(function() {\r\n  console.log(\"this runs before the listeners are invoked\");\r\n});\r\n\r\nlisteners.postFail(function(err) {\r\n  console.log(\"this runs after the listeners are invoked when one of the listeners fails\");\r\n});\r\n```\r\n\r\n##License \r\nMIT",
  "readmeFilename": "README.md",
  "_id": "listener-collection@0.1.0",
  "dist": {
    "shasum": "c840ef10d28da51c1668d1be0f3e8d55f59d53cc"
  },
  "_from": "listener-collection@^0.1.0",
  "_resolved": "https://registry.npmjs.org/listener-collection/-/listener-collection-0.1.0.tgz"
}
